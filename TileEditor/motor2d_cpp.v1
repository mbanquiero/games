#include "stdafx.h"

#include <mmsystem.h>
#include "\Archivos de programa\Microsoft DirectX SDK (April 2006)\include\d3dx9.h"
#pragma warning( disable : 4996 ) // disable deprecated warning 
#include "\msdev\games\clases\vectores.h"
#include "motor2d.h"



/////////////////////////////////////////////////////////////////////////////
// Motor 2d 
/////////////////////////////////////////////////////////////////////////////

void DXEngine2d::Create()
{
	init = FALSE;

	g_pD3D = NULL;
	g_pd3dDevice = NULL;
	g_pVB = NULL;
	g_pQuad = NULL;
	g_pEffect = NULL;			// D3DX effect interface
	hay_shader = FALSE;
	g_pLevel = NULL;			// Buffer para todo el nivel

	cant_bmp = 0;

	// tiles:
	memset(C,0,sizeof(C));
	tile_cant_fil = tile_cant_col = 0;

	// tamaño de pantalla en filas x columnas
	cant_fil = 25;
	cant_col = 40;
	// en pixels
	screen_dx = 480;
	screen_dy = 300;

	sprite_sel = 0;
	vel_h = vel_v = 0;

	sobre_piso = FALSE;

}


// inicializa el Direct X
HRESULT DXEngine2d::DXInit( HWND hWnd)
{

	if(g_pD3D)
		return S_OK;

	if(hWnd==NULL)
		hWnd = AfxGetMainWnd()->m_hWnd;
	m_hWnd = hWnd;

	g_pVB = NULL;
	g_pQuad = NULL;

	// Create the D3D object.
	if( NULL == ( g_pD3D = Direct3DCreate9( D3D_SDK_VERSION ) ) )
	{
		AfxMessageBox("Necesita DIRECT X");
		return E_FAIL;
	}

	// Set up the structure used to create the D3DDevice
	//D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof(d3dpp) );
	d3dpp.Windowed = TRUE;
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	d3dpp.BackBufferFormat = D3DFMT_UNKNOWN;
	d3dpp.EnableAutoDepthStencil = TRUE;
	d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
	d3dpp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES;
	d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
	//d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE	;
	d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
	// ojo que si quiero dibujarn en una textura no anda el zbuffer si le pongo multisample
	
	// Pruebo con zbuffer de 24 bits 
	d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
	if(FAILED( g_pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_hWnd,
									  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
									  &d3dpp, &g_pd3dDevice ) ) )
	{

		// pruebo con otro tipo de buffer y sin antialias
		d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
		d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
		if( FAILED( g_pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_hWnd,
									  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
									  &d3dpp, &g_pd3dDevice ) ) )
		{

			// pruebo sin hardware acceleration layer (HAL)
			if( FAILED( g_pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, m_hWnd,
									  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
									  &d3dpp, &g_pd3dDevice ) ) )
			{
				// no tengo lo que hacer
				AfxMessageBox("Necesita DIRECT X");
				return E_FAIL;
			}
		}
	}

    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE /*3DCULL_CCW */);
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE);			// z-buffer habilitado ?
	g_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS , TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_SHADEMODE,D3DSHADE_GOURAUD);
    g_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, FALSE );


	// D3DTADDRESS_WRAP
	//g_pd3dDevice->SetSamplerState(0,D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);		
	//g_pd3dDevice->SetSamplerState(0,D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);
	g_pd3dDevice->SetSamplerState(0,D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);		
	g_pd3dDevice->SetSamplerState(0,D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);

	g_pd3dDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_POINT);
	g_pd3dDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_POINT);		// D3DTEXF_LINEAR
	g_pd3dDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

	// habilito las tranparencias
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
	//g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_BLENDDIFFUSEALPHA);
	// Color Final = (Source * A) + (Dest * (1-A))
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);		// Source * A
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);	// Dest * (1-A)
	g_pd3dDevice->SetRenderState(D3DRS_BLENDOP,D3DBLENDOP_ADD);			// Suma ambos terminos
	g_pd3dDevice->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL );


    // Texto
	D3DXCreateFont( g_pd3dDevice ,            // D3D device
                         14,					// Height
                         0,                     // Width
                         FW_LIGHT,               // Weight
                         0,                     // MipLevels, 0 = autogen mipmaps
                         FALSE,                 // Italic
                         DEFAULT_CHARSET,       // CharSet
                         OUT_DEFAULT_PRECIS,    // OutputPrecision
                         DEFAULT_QUALITY,       // Quality
                         DEFAULT_PITCH | FF_DONTCARE, // PitchAndFamily
                         "Arial",              // pFaceName
                         &g_pFont);              // ppFont

	D3DXCreateFont( g_pd3dDevice ,22,8,FW_BOLD,0,FALSE,
		DEFAULT_CHARSET,OUT_DEFAULT_PRECIS,DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE, 
                         "Lucida Console",&g_pFontb);
	g_pFontb->PreloadGlyphs('0','9');
	g_pFontb->PreloadGlyphs('a','z');
	g_pFontb->PreloadGlyphs('A','Z');
	
	// font auxiliar
	D3DXCreateFont( g_pd3dDevice ,16,7,FW_NORMAL,0,FALSE,
		DEFAULT_CHARSET,OUT_DEFAULT_PRECIS,DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE, 
                         "Lucida Console",&g_pFont2);
	g_pFont2->PreloadGlyphs('0','9');
	g_pFont2->PreloadGlyphs('a','z');
	g_pFont2->PreloadGlyphs('A','Z');


	// Sprite para las cotas
	D3DXCreateSprite(g_pd3dDevice,&pSprite);
	// lines varios
	D3DXCreateLine(g_pd3dDevice, &ppLine);

	// Material x defecto
	ZeroMemory( &mtrl_std, sizeof(mtrl_std) );
	mtrl_std.Diffuse.r = mtrl_std.Ambient.r = 1;
	mtrl_std.Diffuse.g = mtrl_std.Ambient.g = 1;
	mtrl_std.Diffuse.b = mtrl_std.Ambient.b = 1;
	mtrl_std.Diffuse.a = mtrl_std.Ambient.a = 1;
	g_pd3dDevice->SetMaterial( &mtrl_std);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL);

	// Material transparente
	ZeroMemory( &mtrl_tx, sizeof(mtrl_tx) );
	mtrl_tx.Diffuse.r = mtrl_tx.Ambient.r = 1;
	mtrl_tx.Diffuse.g = mtrl_tx.Ambient.g = 1;
	mtrl_tx.Diffuse.b = mtrl_tx.Ambient.b = 1;
	mtrl_tx.Diffuse.a = mtrl_tx.Ambient.a = 0.5;

	// Material negro
	ZeroMemory( &mtrl_negro, sizeof(mtrl_negro) );
	mtrl_negro.Diffuse.r = mtrl_negro.Ambient.r = 0;
	mtrl_negro.Diffuse.g = mtrl_negro.Ambient.g = 0;
	mtrl_negro.Diffuse.b = mtrl_negro.Ambient.b = 0;
	mtrl_negro.Diffuse.a = mtrl_negro.Ambient.a = 1;


	// Resolucion de pantalla
	sdx = d3dpp.BackBufferWidth*0.35;
	sdy = d3dpp.BackBufferHeight*0.35;

	
	return S_OK;
}




void DXEngine2d::DXCleanTextures()
{
	// Libera las Texturas
	for(int i=0;i<cant_texturas;++i)
		SAFE_RELEASE(g_pTexture[i]);
	cant_texturas = 0;
}

// Carga la textura si no esta, devuelve el nro de textura
int DXEngine2d::cargar_textura(char *filename,int K)
{
	// primero busco que la textura no este repetida
	rtrim(filename);
	int rta = -1;
	int i =0;
	while(i<cant_bmp && rta==-1)
		if(strcmp(bmp_fname[i],filename)==0)
			rta = i;
		else
			++i;

	if(rta==-1)
	{
		// textura nueva, la cargo y la agrego en la lista
		strcpy(bmp_fname[cant_bmp],filename);
		bmp_k[cant_bmp] = K;
		rta = cant_bmp++;
	}
	else
		// actualizo el K
		bmp_k[rta] = K;

	return rta;
}


HRESULT DXEngine2d::DXLoadTextures()
{
	// Primero libero cualquier textura anterior
	DXCleanTextures();

	// Use D3DX to create a texture from a file based image
	// Voy a cargar las texturas

	for(int i=0;i<cant_bmp;++i)
	{
		char *ftexture = bmp_fname[i];
		char fname_aux[MAX_PATH];
		//sacarPath(ftexture,fname_aux);
		sprintf(fname_aux,"texturas\\%s",ftexture);

		// si el nombre del bmp empieza con + , es porque tiene alpha channel (simulado)
		BOOL alpha = FALSE;
		if(ftexture[0]=='+')
		{
			alpha = TRUE;
			if(FAILED( D3DXCreateTextureFromFileEx( g_pd3dDevice, fname_aux, 
							D3DX_DEFAULT,    // default width
                            D3DX_DEFAULT,    // default height
                            1,    // no mip mapping		--> si le pusiera mip-maping despues no lo puedo cambiar.
							// en ese caso deberia cambiar toda la cadena de bitmaps....
                            NULL,    // regular usage
                            D3DFMT_A8R8G8B8,    // 32-bit pixels with alpha
                            D3DPOOL_MANAGED,    // typical memory handling
                            D3DX_DEFAULT,    // no filtering
                            D3DX_DEFAULT,    // no mip filtering
                            0,
							//D3DCOLOR_ARGB(255,255, 0, 255),    // MAGIC COLOR 
                            NULL,    // no image info struct
                            NULL,    // not using 256 colors
							&g_pTexture[cant_texturas])))
				g_pTexture[cant_texturas] = NULL;
		}
		else
		if(ftexture[0]=='-' || ftexture[0]=='*')
		{
			// - indica alpha chanel + automatic mipmaping
			// * indica alpha chanel + sin mipmaping
			sprintf(fname_aux,"texturas\\%s",ftexture+1);
			alpha = TRUE;
			if(FAILED( D3DXCreateTextureFromFileEx( g_pd3dDevice, fname_aux, 
							D3DX_DEFAULT,    // default width
                            D3DX_DEFAULT,    // default height
                            ftexture[0]=='*'?1:0,    // automatic mipmaping: ojo....en este caso tengo cambiar toda la cadena de bitmaps.... o sin mip maping
                            NULL,    // regular usage
                            D3DFMT_A8R8G8B8,    // 32-bit pixels with alpha
                            D3DPOOL_MANAGED,    // typical memory handling
                            D3DX_DEFAULT,    // no filtering
                            D3DX_DEFAULT,    // no mip filtering
                            0,
							//D3DCOLOR_ARGB(255,0, 0, 0),    // MAGIC COLOR 
                            NULL,    // no image info struct
                            NULL,    // not using 256 colors
							&g_pTexture[cant_texturas])))
				g_pTexture[cant_texturas] = NULL;
		}
		else
		if(bmp_k[i]==-1)
		{
			// Textura sprite (sin MIPMAPING)
			if(FAILED( D3DXCreateTextureFromFileEx( g_pd3dDevice, fname_aux, 
							D3DX_DEFAULT,    // default width
                            D3DX_DEFAULT,    // default height
                            1,    // no mip mapping
                            NULL,    // regular usage
                            D3DFMT_A8R8G8B8,    // 32-bit pixels with alpha
                            D3DPOOL_MANAGED,    // typical memory handling
                            D3DX_DEFAULT,    // no filtering
                            D3DX_DEFAULT,    // no mip filtering
                            0,
                            NULL,    // no image info struct
                            NULL,    // not using 256 colors
							&g_pTexture[cant_texturas])))
				g_pTexture[cant_texturas] = NULL;
		}
		else
		{
			// abro el bmp comun y corriente (con mipmaing
			if(FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, fname_aux, &g_pTexture[cant_texturas])))
				g_pTexture[cant_texturas] = NULL;
		}

		if(alpha)
		{
			// Initialize the alpha channel
			D3DLOCKED_RECT lockedRect;

			if(SUCCEEDED(g_pTexture[cant_texturas]->LockRect(0, &lockedRect, NULL, D3DLOCK_DISCARD )))
			{
				D3DSURFACE_DESC desc;
				g_pTexture[cant_texturas]->GetLevelDesc(0,&desc);
				int m_dwWidth = desc.Width;
				int m_dwHeight = desc.Height;
				int pitch = lockedRect.Pitch / sizeof(DWORD);
				for( int y=0; y < m_dwHeight; y++ )
				{	
					//int dwOffset = y*m_dwWidth;
					int dwOffset = y*pitch;
					float grad;
					if(y<m_dwHeight/4.0)
						grad = 4.0*(float)y/(float)m_dwHeight;
					else
					if(y>3.0*m_dwHeight/4.0)
						grad = 4.0*(1.0-((float)y)/(float)m_dwHeight);
					else
						grad = 1.0;
					for( int x=0; x < m_dwWidth; x++ )
					{

						//DWORD color = *(((DWORD *)lockedRect.pBits)+(dwOffset+x));
						BYTE *color = (BYTE *)(((DWORD *)lockedRect.pBits)+(dwOffset+x));
						BYTE b = color[0];
						BYTE g = color[1];
						BYTE r = color[2];


						*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB((BYTE)(255.0*(1-grad*0.75)),r,g,b);

						//if(color==0xFFFF00ff)
							// MAGIC COLOR
							//*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB(0,0,0,0);
					}
				}
				g_pTexture[cant_texturas]->UnlockRect(0);
			}
		}


		// paso a la siguiente textura
		++cant_texturas;

	}

	// si todo salio bien cant_texturas==cant_bmp
    return S_OK;
}


HRESULT SetAlphaChannel(LPDIRECT3DTEXTURE9  g_pTexture,BYTE r0,BYTE g0,BYTE b0)
{
	// Initialize the alpha channel
	// tengo que hacer el reemplazo en TODOS los mipmaps generados para 
	// esta textura
	D3DLOCKED_RECT lockedRect;
	UINT cant_mipmaps = g_pTexture->GetLevelCount();
	for(UINT i=0;i<cant_mipmaps;++i)
	if(SUCCEEDED(g_pTexture->LockRect(i, &lockedRect, NULL, D3DLOCK_DISCARD )))
	{
		D3DSURFACE_DESC desc;
		g_pTexture->GetLevelDesc(i,&desc);
		int m_dwWidth = desc.Width;
		int m_dwHeight = desc.Height;
		int pitch = lockedRect.Pitch / sizeof(DWORD);
		for( int y=0; y < m_dwHeight; y++ )
		{	
			int dwOffset = y*pitch;
			for( int x=0; x < m_dwWidth; x++ )
			{

				BYTE *color = (BYTE *)(((DWORD *)lockedRect.pBits)+(dwOffset+x));
				BYTE b = color[0];
				BYTE g = color[1];
				BYTE r = color[2];

				if(abs(b-b0)<4 && abs(g-g0)<4 && abs(r-r0)<4)		// es el mask transparente
					*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB(0,r,g,b);
				else
					*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB(255,r,g,b);

			}
		}
		g_pTexture->UnlockRect(i);
	}
    return S_OK;
}

HRESULT SetAlphaChannel(LPDIRECT3DTEXTURE9  g_pTexture,BYTE alpha,BYTE mask_r,BYTE mask_g,BYTE mask_b)
{
	// Initialize the alpha channel
	// tengo que hacer el reemplazo en TODOS los mipmaps generados para 
	// esta textura
	D3DLOCKED_RECT lockedRect;
	UINT cant_mipmaps = g_pTexture->GetLevelCount();
	for(UINT i=0;i<cant_mipmaps;++i)
	if(SUCCEEDED(g_pTexture->LockRect(i, &lockedRect, NULL, D3DLOCK_DISCARD )))
	{
		D3DSURFACE_DESC desc;
		g_pTexture->GetLevelDesc(i,&desc);
		int m_dwWidth = desc.Width;
		int m_dwHeight = desc.Height;
		int pitch = lockedRect.Pitch / sizeof(DWORD);
		for( int y=0; y < m_dwHeight; y++ )
		{	
			int dwOffset = y*pitch;
			for( int x=0; x < m_dwWidth; x++ )
			{

				BYTE *color = (BYTE *)(((DWORD *)lockedRect.pBits)+(dwOffset+x));
				BYTE b = color[0];
				BYTE g = color[1];
				BYTE r = color[2];
				if(abs(b-mask_b)<10 && abs(g-mask_g)<10 && abs(r-mask_r)<10)		// es el mask transparente
					*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB(0,r,g,b);
				else
				*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB(alpha,r,g,b);

			}
		}
		g_pTexture->UnlockRect(i);
	}
    return S_OK;
}

HRESULT SetAlphaChannel(LPDIRECT3DTEXTURE9  g_pTexture,BYTE alpha)
{
	// Initialize the alpha channel
	// tengo que hacer el reemplazo en TODOS los mipmaps generados para 
	// esta textura
	D3DLOCKED_RECT lockedRect;
	UINT cant_mipmaps = g_pTexture->GetLevelCount();
	for(UINT i=0;i<cant_mipmaps;++i)
	if(SUCCEEDED(g_pTexture->LockRect(i, &lockedRect, NULL, D3DLOCK_DISCARD )))
	{
		D3DSURFACE_DESC desc;
		g_pTexture->GetLevelDesc(i,&desc);
		int m_dwWidth = desc.Width;
		int m_dwHeight = desc.Height;
		int pitch = lockedRect.Pitch / sizeof(DWORD);
		for( int y=0; y < m_dwHeight; y++ )
		{	
			int dwOffset = y*pitch;
			for( int x=0; x < m_dwWidth; x++ )
			{

				BYTE *color = (BYTE *)(((DWORD *)lockedRect.pBits)+(dwOffset+x));
				BYTE b = color[0];
				BYTE g = color[1];
				BYTE r = color[2];
				*(((DWORD *)lockedRect.pBits)+(dwOffset+x)) = D3DCOLOR_ARGB(alpha,r,g,b);

			}
		}
		g_pTexture->UnlockRect(i);
	}
    return S_OK;
}

HRESULT DXEngine2d::LoadFx(char *fx_file)
{
	// primero busco el archivo en el directorio local
	ID3DXBuffer *pBuffer = NULL;
	HRESULT hr = D3DXCreateEffectFromFile( g_pd3dDevice, fx_file,
			NULL, NULL, D3DXFX_NOT_CLONEABLE, NULL, &g_pEffect, &pBuffer);
	if( FAILED(hr) )
	{
		char *saux = (char*)pBuffer->GetBufferPointer();
		AfxMessageBox(saux);
	}
	return hr;
}


// Libero toda la memoria de los objetos usados
void DXEngine2d::DXCleanup()
{

	if(g_pD3D==NULL)
		return;

	SAFE_RELEASE(pSprite);
	SAFE_RELEASE(ppLine);
    SAFE_RELEASE(g_pFont);
    SAFE_RELEASE(g_pFontb);
    SAFE_RELEASE(g_pFont2);

	// borro el buffer de vertices
	SAFE_RELEASE(g_pVB);
	SAFE_RELEASE(g_pQuad);
	SAFE_RELEASE(g_pLevel);

	// el dipositivo 
	SAFE_RELEASE(g_pd3dDevice );
	SAFE_RELEASE(g_pD3D);
	SAFE_RELEASE(g_pEffect);

}





// Render states
void DXEngine2d::SaveRenderStates()
{
	g_pd3dDevice->GetRenderState( D3DRS_ZENABLE, &ant_zenable);
	g_pd3dDevice->GetRenderState( D3DRS_CULLMODE, &ant_cullmode);
	g_pd3dDevice->GetRenderState( D3DRS_DIFFUSEMATERIALSOURCE, &ant_dmsource);
	g_pd3dDevice->GetRenderState( D3DRS_ALPHABLENDENABLE,&ant_alpha);
}

void DXEngine2d::RestoreRenderStates()
{

	g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, ant_zenable);
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, ant_cullmode);
	g_pd3dDevice->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE, ant_dmsource);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,ant_alpha);

}





/////////////////////////////////////////////////////////////////////////////
// niveles (tiles)
/////////////////////////////////////////////////////////////////////////////
HRESULT DXEngine2d::LoadLevel(char tdx,char tdy)
{
	// Cargo el nivel:
	atlas = cargar_textura("atlas.bmp",-1);
	// Cargo el atlas de sprites
	sprites = cargar_textura("sprites.bmp",-1);

	// Cargo las texturas pp dichas
	DXLoadTextures();

	// tamaño de los tiles
	tile_dx = tdx;
	tile_dy = tdy;

	D3DSURFACE_DESC desc;
	g_pTexture[atlas]->GetLevelDesc(0,&desc);
	atlas_dx = desc.Width;
	atlas_dy = desc.Height;
	tile_cant_col = atlas_dx/tile_dx;
	tile_cant_fil = atlas_dy/tile_dy;

	// Tamaño de los sprites (de momento fijos)
	sprite_dx = 24;
	sprite_dy = 36;
	// Seteo el canal alfa de los sprites
	SetAlphaChannel(g_pTexture[sprites],255,0,255);
	// esqueleto
	cant_vertebras = 0;
	vertebra[cant_vertebras++] = CPoint(7,0);			// Pie Izquierdo
	vertebra[cant_vertebras++] = CPoint(15,0);			// Pie Derecho
	vertebra[cant_vertebras++] = CPoint(11,10);			// tronco
	vertebra[cant_vertebras++] = CPoint(11,15);			// Cuello
	vertebra[cant_vertebras++] = CPoint(11,29);			// Cabeza
	vertebra[cant_vertebras++] = CPoint(6,15);			// Hombro Izquierdo
	vertebra[cant_vertebras++] = CPoint(16,15);			// Hombro Derecho
	vertebra[cant_vertebras++] = CPoint(2,8);			// Mano Izquierda
	vertebra[cant_vertebras++] = CPoint(19,8);			// Mano Derecha


	// inicializo con todo el atlas 
	for(int i=0;i<MAX_TILE_Y;++i)
		for(int j=0;j<MAX_TILE_X;++j)
		{
			C[i][j].flags = 0;
			C[i][j].fil = 0;
			C[i][j].col = 0;
		}


	// Creo los vertices de la parte que se ve en pantalla
	int cant_v = cant_fil*cant_col*2*3;
	SAFE_RELEASE(g_pQuad);
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( cant_v*sizeof(QUADVERTEX),
                                                  0, D3DFVF_QUADVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pQuad, NULL ) ) )
    {
        return E_FAIL;
    }

	// Creo los vertices de todo el nivel (para el preview)
	cant_v = MAX_TILE_X*MAX_TILE_Y*2*3;
	SAFE_RELEASE(g_pLevel);
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( cant_v*sizeof(QUADVERTEX),
                                                  0, D3DFVF_QUADVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pLevel, NULL ) ) )
    {
        return E_FAIL;
    }


	LoadPreviewLevel();
    return S_OK;

}


HRESULT DXEngine2d::Render(int x0,int y0,float ex,float ey,BOOL preview)
{
	// Quad para postprocess 2d
	int ox = 2;
	int oy = 2;

	int cant_v = cant_fil*cant_col*2*3;
	int size_vert = sizeof(QUADVERTEX)*cant_v;
    QUADVERTEX vertices[MAX_TILE_X_PAN*2*3];
    // Leer esto en el manual del directX : "Directly Mapping Texels to Pixels"
    float desf = 0.5;
	float du = (float)tile_dx/(float)atlas_dx;
	float dv = (float)tile_dy/(float)atlas_dy;

	// Correccion de escala
	// la pantalla tiene cant_fil x cant_col, y eso ocupa screen_dy x screen_dx pixels, 
	float kx = (float)screen_dx / (float)(cant_col*tile_dx);		// si coincide exacto kx = 1, por ejemplo 40 col x 8 = 320 px
	float ky = (float)screen_dy / (float)(cant_fil*tile_dy);		// si coincide exacto ky = 1, por ejemplo 25 col x 8 = 200 px

	// ajusto la escala
	ex*=kx;
	ey*=ky;

	int j0 = x0/tile_dx;
	float desf_x = ex*(x0%tile_dx) - desf;
	int i0 = y0/tile_dy;
	float desf_y = ey*(y0%tile_dy) - desf;



	int t = 0;
	for(int i=0;i<cant_fil;++i)
	{
		for(int j=0;j<cant_col;++j)
		{

			float u = (float)C[i0+i][j0+j].col *du;
			float v = (float)C[i0+i][j0+j].fil *dv;

			vertices[t].pos = D3DXVECTOR4(ox + ex*j*tile_dx-desf_x, oy + ey*i*tile_dy-desf_y, 0.0f, 1.0f);
			vertices[t].tu = u;
			vertices[t].tv = v;
			++t;

			vertices[t].pos = D3DXVECTOR4(ox + ex*(j+1)*tile_dx-desf_x,oy +  ey*i*tile_dy-desf_y, 0.0f, 1.0f);
			vertices[t].tu = u+du;
			vertices[t].tv = v;
			++t;

			vertices[t].pos = D3DXVECTOR4(ox + ex*(j+1)*tile_dx-desf_x,oy +  ey*(i+1)*tile_dy-desf_y, 0.0f, 1.0f);
			vertices[t].tu = u+du;
			vertices[t].tv = v+dv;
			++t;

			
			vertices[t] = vertices[t-3];
			vertices[t+1] = vertices[t-1];
			vertices[t+2].pos = D3DXVECTOR4(ox + ex*j*tile_dx-desf_x,oy +  ey*(i+1)*tile_dy-desf_y, 0.0f, 1.0f);
			vertices[t+2].tu = u;
			vertices[t+2].tv = v+dv;
			t+=3;
		}
	}



    VOID* pQuad;
    if( FAILED( g_pQuad->Lock( 0, size_vert, (void**)&pQuad, 0 ) ) )
        return E_FAIL;
    memcpy( pQuad, vertices, size_vert );
    g_pQuad->Unlock();

	g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(128,128,128), 1, 0 );
	if( SUCCEEDED(g_pd3dDevice->BeginScene()))
	{

		g_pd3dDevice->SetStreamSource( 0, g_pQuad, 0, sizeof(QUADVERTEX));
		g_pd3dDevice->SetFVF( D3DFVF_QUADVERTEX);
		g_pd3dDevice->SetTexture( 0, g_pTexture[atlas]);


		D3DVIEWPORT9 viewport,viewport_ant;
		g_pd3dDevice->GetViewport(&viewport_ant);
		viewport.MaxZ = 1;
		viewport.MinZ = 0;
		viewport.X = ox;
		viewport.Y = oy;
		viewport.Width = ox + screen_dx*ex;
		viewport.Height = oy + screen_dy*ey;
		g_pd3dDevice->SetViewport(&viewport);

		g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 2*cant_fil*cant_col);
		g_pd3dDevice->SetViewport(&viewport_ant);


		if(preview)
		{
			// Render Preview del Nivel
			g_pd3dDevice->SetStreamSource( 0, g_pLevel, 0, sizeof(QUADVERTEX));
			for(int i=0;i<MAX_TILE_Y;++i)
				g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, i*6*MAX_TILE_X, 2*MAX_TILE_X);
		}

		// dibujo el sprite
		if(sprite_sel!=-1)
			RenderSprite(ox + (pos_x - j0*tile_dx)*ex,
						oy + (pos_y - (i0+3)*tile_dy)*ey 
						,sprite_sel,ex,ey);

		g_pd3dDevice->EndScene();
	}

	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	return S_OK;

}

HRESULT DXEngine2d::RenderTile(int x0,int y0,int dx,int dy,int sel)
{
	LPDIRECT3DVERTEXBUFFER9 g_pQuadAux;
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 4*sizeof(QUADVERTEX),
                                                  0, D3DFVF_QUADVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pQuadAux, NULL ) ) )
    {
        return E_FAIL;
    }


    QUADVERTEX vertices[4];
    float desf = 0.5f;
	float du = (float)tile_dx / (float)atlas_dx;
	float dv = (float)tile_dy / (float)atlas_dy;

	int i = sel / tile_cant_col;
	int j = sel % tile_cant_col;

	float u = (float)j*du;
	float v = (float)i*dv;

	vertices[0].pos = D3DXVECTOR4(x0-desf, y0-desf, 0.0f, 1.0f);
	vertices[0].tu = u;
	vertices[0].tv = v;

	vertices[1].pos = D3DXVECTOR4(x0+dx-desf, y0-desf, 0.0f, 1.0f);
	vertices[1].tu = u+du;
	vertices[1].tv = v;
	
	vertices[3].pos = D3DXVECTOR4(x0+dx-desf, y0+dy-desf, 0.0f, 1.0f);
	vertices[3].tu = u+du;
	vertices[3].tv = v+dv;

	vertices[2].pos = D3DXVECTOR4(x0-desf, y0+dy-desf, 0.0f, 1.0f);
	vertices[2].tu = u;
	vertices[2].tv = v+dv;

    VOID* pQuad;
    if( FAILED( g_pQuadAux->Lock( 0, sizeof(vertices), (void**)&pQuad, 0 ) ) )
        return E_FAIL;
    memcpy( pQuad, vertices, sizeof(vertices));
    g_pQuadAux->Unlock();

	if( SUCCEEDED(g_pd3dDevice->BeginScene()))
	{

		D3DVIEWPORT9 viewport,viewport_ant;
		g_pd3dDevice->GetViewport(&viewport_ant);
		viewport.MaxZ = 1;
		viewport.MinZ = 0;
		viewport.X = x0;
		viewport.Y = y0;
		viewport.Width = dx;
		viewport.Height = dy;
		g_pd3dDevice->SetViewport(&viewport);
		g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(128,128,128), 1, 0 );
		g_pd3dDevice->SetStreamSource( 0, g_pQuadAux, 0, sizeof(QUADVERTEX));
		g_pd3dDevice->SetFVF( D3DFVF_QUADVERTEX);
		g_pd3dDevice->SetTexture( 0, g_pTexture[atlas]);

		g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2);
		g_pd3dDevice->SetViewport(&viewport_ant);
		g_pd3dDevice->EndScene();
	}

	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	SAFE_RELEASE(g_pQuadAux);
	return S_OK;
}


/*
HRESULT DXEngine2d::RenderTiles(int sel)
{
	int cant_tiles = tile_cant_fil*tile_cant_col;
	int size_vert = (cant_tiles*2*3 + 6)*sizeof(QUADVERTEX);
	LPDIRECT3DVERTEXBUFFER9 g_pQuadAux;
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( size_vert,
                                                  0, D3DFVF_QUADVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pQuadAux, NULL ) ) )
    {
        return E_FAIL;
    }


    QUADVERTEX *vertices = (QUADVERTEX *)new char[size_vert];
    float desf = 0.5f;
	float du = (float)tile_dx / (float)atlas_dx;
	float dv = (float)tile_dy / (float)atlas_dy;
	float ex = 3;
	float ey = 3;

	int oy = 410;
	int dc = 900./ (tile_dx * ex);		//	tiles x fila
	int df = 300./ (tile_dy * ey);		//	cant de filas 
	int t = 0;
	for(int i=0;i<df;++i)
	{
		for(int j=0;j<dc;++j)
		{

			int nro_tile = i*dc + j;
			if(nro_tile<cant_tiles)
			{
				int ii = nro_tile / tile_cant_col;
				int jj = nro_tile % tile_cant_col;

				float u = (float)jj * du;
				float v = (float)ii * dv;

				vertices[t].pos = D3DXVECTOR4(ex*j*tile_dx-desf, oy+ ey*i*tile_dy-desf, 0.0f, 1.0f);
				vertices[t].tu = u;
				vertices[t].tv = v;
				++t;

				vertices[t].pos = D3DXVECTOR4(ex*(j+1)*tile_dx-desf, oy+ ey*i*tile_dy-desf, 0.0f, 1.0f);
				vertices[t].tu = u+du;
				vertices[t].tv = v;
				++t;

				vertices[t].pos = D3DXVECTOR4(ex*(j+1)*tile_dx-desf, oy+ ey*(i+1)*tile_dy-desf, 0.0f, 1.0f);
				vertices[t].tu = u+du;
				vertices[t].tv = v+dv;
				++t;

				
				vertices[t] = vertices[t-3];
				vertices[t+1] = vertices[t-1];
				vertices[t+2].pos = D3DXVECTOR4(ex*j*tile_dx-desf, oy+ ey*(i+1)*tile_dy-desf, 0.0f, 1.0f);
				vertices[t+2].tu = u;
				vertices[t+2].tv = v+dv;
				t+=3;
			}
		}
	}

	// Agrego un quad mas con el tile seleccionado
	if(sel!=-1)
	{
		int ii = sel / tile_cant_col;
		int jj = sel % tile_cant_col;

		float u = (float)jj/ (float)tile_cant_col;
		float v = (float)ii/ (float)tile_cant_fil;
		int ox = 900;
		int oy = 410;

		vertices[t].pos = D3DXVECTOR4(ox, oy, 0.0f, 1.0f);
		vertices[t].tu = u;
		vertices[t].tv = v;
		++t;

		vertices[t].pos = D3DXVECTOR4(ox+tile_dx*4, oy, 0.0f, 1.0f);
		vertices[t].tu = u+du;
		vertices[t].tv = v;
		++t;

		vertices[t].pos = D3DXVECTOR4(ox+tile_dx*4, oy+tile_dy*4, 0.0f, 1.0f);
		vertices[t].tu = u+du;
		vertices[t].tv = v+dv;
		++t;

		
		vertices[t] = vertices[t-3];
		vertices[t+1] = vertices[t-1];
		vertices[t+2].pos = D3DXVECTOR4(ox, oy+ tile_dy*4, 0.0f, 1.0f);
		vertices[t+2].tu = u;
		vertices[t+2].tv = v+dv;
		t+=3;
	}

    VOID* pQuad;
    if( FAILED( g_pQuadAux->Lock( 0, size_vert, (void**)&pQuad, 0 ) ) )
        return E_FAIL;
    memcpy( pQuad, vertices, size_vert);
    g_pQuadAux->Unlock();
	delete vertices;


	g_pd3dDevice->SetStreamSource( 0, g_pQuadAux, 0, sizeof(QUADVERTEX));
	g_pd3dDevice->SetFVF( D3DFVF_QUADVERTEX);
	g_pd3dDevice->SetTexture( 0, g_pTexture[atlas]);

	g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 2*cant_tiles + (sel!=-1?2:0));

	SAFE_RELEASE(g_pQuadAux);
	return S_OK;

}
*/

HRESULT DXEngine2d::LoadPreviewLevel()
{
	// Quad para postprocess 2d
	int cant_vert = MAX_TILE_X*MAX_TILE_Y*2*3;
	int size_vert = sizeof(QUADVERTEX)*cant_vert;
    QUADVERTEX *vertices = new QUADVERTEX[size_vert];
    float desf = 0.5f;
	float du = (float)tile_dx / (float)atlas_dx;
	float dv = (float)tile_dx / (float)atlas_dx;
	int ox = 500;
	int oy = 2;
	float ex = (float)(1024 - ox)/(float)(MAX_TILE_X*tile_dx);
	float ey = (float)(600 - oy)/(float)(MAX_TILE_Y*tile_dy);

	int t = 0;
	for(int i=0;i<MAX_TILE_Y;++i)
	{
		for(int j=0;j<MAX_TILE_X;++j)
		{

			float u = (float)C[i][j].col * du;
			float v = (float)C[i][j].fil * dv;

			vertices[t].pos = D3DXVECTOR4(ox + ex*j*tile_dx - desf, oy + ey*i*tile_dy- desf, 0.0f, 1.0f);
			vertices[t].tu = u;
			vertices[t].tv = v;
			++t;

			vertices[t].pos = D3DXVECTOR4(ox + ex*(j+1)*tile_dx- desf, oy + ey*i*tile_dy- desf, 0.0f, 1.0f);
			vertices[t].tu = u+du;
			vertices[t].tv = v;
			++t;

			vertices[t].pos = D3DXVECTOR4(ox + ex*(j+1)*tile_dx- desf, oy + ey*(i+1)*tile_dy- desf, 0.0f, 1.0f);
			vertices[t].tu = u+du;
			vertices[t].tv = v+dv;
			++t;

			
			vertices[t] = vertices[t-3];
			vertices[t+1] = vertices[t-1];
			vertices[t+2].pos = D3DXVECTOR4(ox + ex*j*tile_dx- desf, oy + ey*(i+1)*tile_dy- desf, 0.0f, 1.0f);
			vertices[t+2].tu = u;
			vertices[t+2].tv = v+dv;
			t+=3;
		}
	}

    QUADVERTEX * pQuad;
    if( FAILED( g_pLevel->Lock( 0, size_vert, (void**)&pQuad, 0 ) ) )
        return E_FAIL;
    memcpy( pQuad, vertices, size_vert);
    
	g_pLevel->Unlock();
	delete vertices;
	return S_OK;

}


HRESULT DXEngine2d::ReloadPreviewLevel(int i,int j)
{
    QUADVERTEX vertices[6];
    float desf = 0.5f;
	float du = (float)tile_dx / (float)atlas_dx;
	float dv = (float)tile_dx / (float)atlas_dx;
	int ox = 500;
	int oy = 2;
	float ex = (1024 - ox)/(MAX_TILE_X*tile_dx);
	float ey = (600 - oy)/(MAX_TILE_Y*tile_dy);
	/*if(ex<ey)
		ey = ex;
	else
		ex = ey;
	*/

	int t = 0;
	float u = (float)C[i][j].col * du;
	float v = (float)C[i][j].fil * dv;

	vertices[t].pos = D3DXVECTOR4(ox + ex*j*tile_dx - desf, oy + ey*i*tile_dy- desf, 0.0f, 1.0f);
	vertices[t].tu = u;
	vertices[t].tv = v;
	++t;

	vertices[t].pos = D3DXVECTOR4(ox + ex*(j+1)*tile_dx- desf, oy + ey*i*tile_dy- desf, 0.0f, 1.0f);
	vertices[t].tu = u+du;
	vertices[t].tv = v;
	++t;

	vertices[t].pos = D3DXVECTOR4(ox + ex*(j+1)*tile_dx- desf, oy + ey*(i+1)*tile_dy- desf, 0.0f, 1.0f);
	vertices[t].tu = u+du;
	vertices[t].tv = v+dv;
	++t;

	
	vertices[t] = vertices[t-3];
	vertices[t+1] = vertices[t-1];
	vertices[t+2].pos = D3DXVECTOR4(ox + ex*j*tile_dx- desf, oy + ey*(i+1)*tile_dy- desf, 0.0f, 1.0f);
	vertices[t+2].tu = u;
	vertices[t+2].tv = v+dv;
	t+=3;


	int offset = (i*MAX_TILE_X + j)*6*sizeof(QUADVERTEX);
    VOID* pQuad;
    if( FAILED( g_pLevel->Lock( offset, sizeof(vertices), (void**)&pQuad, 0 ) ) )
        return E_FAIL;
    memcpy( pQuad, vertices, sizeof(vertices));
	g_pLevel->Unlock();
	return S_OK;

}



void DXEngine2d::grabar_mapa(char *fname)
{
	FILE *fp = fopen(fname,"wb");

	if(!fp)
		return;

	char mask[] = { 'M','A','P','2','D'};
	fwrite(mask,5,1,fp);
	fwrite(C,sizeof(C),1,fp);
	fclose(fp);
}


void DXEngine2d::cargar_mapa(char *fname)
{
	FILE *fp = fopen(fname,"rb");

	if(!fp)
		return;

	char mask[5];
	fread(mask,5,1,fp);
	fread(C,sizeof(C),1,fp);
	fclose(fp);
}


void DXEngine2d::importar(char *fname)
{
	FILE *fp = fopen(fname,"rt");

	if(!fp)
		return;

	char buffer[255];
	fgets(buffer,255,fp);		// nro de version
	fgets(buffer,255,fp);		// filas x columnas

	int i = 0;
	int j = 0;
	char c;
	char saux[20];
	int t = 0;
	int nro_tile;
	while((c =fgetc(fp))!=EOF)
	{
		if(c==',' || c=='\n')
		{
			saux[t] = '\0';
			t = 0;
			nro_tile = atoi(saux);
			C[250-i-1][j].fil = 24 - nro_tile / 25;
			C[250-i-1][j].col = nro_tile % 25;

			int flags = 0;
			// numero real de tile (corregido a atlas de q estoy usando)
			int ntile = C[250-i-1][j].fil * tile_cant_col + C[250-i-1][j].col;
			switch(ntile)
			{
				case 1009:
					// bloque negro vacio
					flags = 0;
					break;
				case 1019:
				case 1021:
					// escalera
					flags = TILE_ESCALERA;
					break;
				case 852:
				case 854:
					// escalera c/ piso
					flags = TILE_ESCALERA | TILE_PISO;
					break;
				default:
					flags = TILE_PISO;
					break;

			}
			C[250-i-1][j].flags = flags;


			if(c==',')
				++j;
			else
			{
				j = 0;
				++i;
			}
		}
		else
			saux[t++] = c;
	}

	fclose(fp);
}


void DXEngine2d::grabar_tile(int sel[],int cant_f,int cant_c)
{
	HRESULT rta;
	RECT rc_tile = {0, 0, tile_dx, tile_dy};
	// Creo una textura que abarque todos los tiles seleccionados
	LPDIRECT3DTEXTURE9 texture;
	rta = D3DXCreateTexture(g_pd3dDevice, tile_dx*cant_c, tile_dy*cant_f, 1, 
			NULL, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &texture);
	LPDIRECT3DSURFACE9 pSurfaceOut;
	texture->GetSurfaceLevel(0, &pSurfaceOut);

	int t = 0;
	for(int i=0;i<cant_f;++i)
		for(int j=0;j<cant_c;++j)
		{
			int ii = sel[t] / tile_cant_col;
			int jj = sel[t] % tile_cant_col;

			// Acceso a la memoria del atlas, tomando el rect. que corresponde al tile ii,jj
			RECT rc = {jj*tile_dx,ii*tile_dy,(jj+1)*tile_dx,(ii+1)*tile_dy};
			D3DLOCKED_RECT lockedRect;
			rta = g_pTexture[atlas]->LockRect(0, &lockedRect,&rc, D3DLOCK_DISCARD);
			
			// Y lo copio en la textura, en la posicion i,j
			RECT rc2 = {j*tile_dx, i*tile_dy, (j+1)*tile_dx, (i+1)*tile_dy};
			rta = D3DXLoadSurfaceFromMemory(pSurfaceOut,NULL,&rc2,lockedRect.pBits,D3DFMT_A8R8G8B8,
					lockedRect.Pitch,NULL,&rc_tile,D3DX_FILTER_NONE, 0);
  
			g_pTexture[atlas]->UnlockRect(0);

			// paso al siguiente tile
			++t;
		}

	// Grabo la textura pp dicha:
	rta = D3DXSaveTextureToFile("tile.bmp",D3DXIFF_BMP ,texture,NULL);
	
	// libero la superficie y la textura auxiliar
	SAFE_RELEASE( pSurfaceOut);
	SAFE_RELEASE( texture);
	
}


void DXEngine2d::update_tile(int sel[],int cant_f,int cant_c)
{
	HRESULT rta;
	RECT rc_tile = {0, 0, tile_dx, tile_dy};


	// 
	LPDIRECT3DTEXTURE9 texture;
	rta = D3DXCreateTextureFromFileEx( g_pd3dDevice, "tile.bmp", 
			D3DX_DEFAULT_NONPOW2,    D3DX_DEFAULT_NONPOW2,    
                            1,    // no mip mapping
                            NULL,    // regular usage
                            D3DFMT_A8R8G8B8,    // 32-bit pixels with alpha
                            D3DPOOL_MANAGED,    // typical memory handling
                            D3DX_DEFAULT,    // no filtering
                            D3DX_DEFAULT,    // no mip filtering
                            0,
                            NULL,    // no image info struct
                            NULL,    // not using 256 colors
							&texture);
				
	D3DSURFACE_DESC desc;
	texture->GetLevelDesc(0,&desc);
	int m_dwWidth = desc.Width;
	int m_dwHeight = desc.Height;

	// Acceso a la superficie del atlas
	LPDIRECT3DSURFACE9 pSurfaceOut;
	g_pTexture[atlas]->GetSurfaceLevel(0, &pSurfaceOut);

	int t = 0;
	for(int i=0;i<cant_f;++i)
		for(int j=0;j<cant_c;++j)
		{
			int ii = sel[t] / tile_cant_col;
			int jj = sel[t] % tile_cant_col;

			// Acceso a la memoria de la textura , tomando el rect. que corresponde al tile i,j
			RECT rc2 = {j*tile_dx, i*tile_dy, (j+1)*tile_dx, (i+1)*tile_dy};
			D3DLOCKED_RECT lockedRect;
			rta = texture->LockRect(0, &lockedRect,&rc2, D3DLOCK_DISCARD);
			
			// Y lo copio en la atlas , en la posicion ii,jj
			RECT rc = {jj*tile_dx,ii*tile_dy,(jj+1)*tile_dx,(ii+1)*tile_dy};
			rta = D3DXLoadSurfaceFromMemory(pSurfaceOut,NULL,&rc,lockedRect.pBits,D3DFMT_A8R8G8B8,
					lockedRect.Pitch,NULL,&rc_tile,D3DX_FILTER_NONE, 0);
  
			texture->UnlockRect(0);

			// paso al siguiente tile
			++t;
		}

	// libero la superficie y la textura auxiliar
	SAFE_RELEASE( pSurfaceOut);
	SAFE_RELEASE( texture);

	// Grabo el atlas de texturas
	char fname_aux[MAX_PATH];
	sprintf(fname_aux,"texturas\\%s",bmp_fname[atlas]);
	rta = D3DXSaveTextureToFile(fname_aux,D3DXIFF_BMP ,g_pTexture[atlas],NULL);

	
}



/////////////////////////////////////////////////////////////////////////////
// sprites
/////////////////////////////////////////////////////////////////////////////

HRESULT DXEngine2d::RenderSprite(int x0,int y0,int nro_sprite,float ex,float ey)
{
	LPDIRECT3DVERTEXBUFFER9 g_pQuadAux;
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 4*sizeof(QUADVERTEX),
                                                  0, D3DFVF_QUADVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pQuadAux, NULL ) ) )
    {
        return E_FAIL;
    }


	// de momento el atlas de sprite esta fijo en 512 x 512
    QUADVERTEX vertices[4];
    float desf = 0.5f;
	float du = (float)sprite_dx / (float)512;
	float dv = (float)sprite_dy / (float)512;
	int cant_col = 512 / sprite_dx;

	int i = nro_sprite / cant_col;
	int j = nro_sprite % cant_col;

	float u = (float)j*du;
	float v = (float)i*dv;

	vertices[0].pos = D3DXVECTOR4(x0-desf, y0-desf, 0.0f, 1.0f);
	vertices[0].tu = u;
	vertices[0].tv = v;

	vertices[1].pos = D3DXVECTOR4(x0+sprite_dx*ex-desf, y0-desf, 0.0f, 1.0f);
	vertices[1].tu = u+du;
	vertices[1].tv = v;
	
	vertices[3].pos = D3DXVECTOR4(x0+sprite_dx*ex-desf, y0+sprite_dy*ey-desf, 0.0f, 1.0f);
	vertices[3].tu = u+du;
	vertices[3].tv = v+dv;

	vertices[2].pos = D3DXVECTOR4(x0-desf, y0+sprite_dy*ey-desf, 0.0f, 1.0f);
	vertices[2].tu = u;
	vertices[2].tv = v+dv;

    VOID* pQuad;
    if( FAILED( g_pQuadAux->Lock( 0, sizeof(vertices), (void**)&pQuad, 0 ) ) )
        return E_FAIL;
    memcpy( pQuad, vertices, sizeof(vertices));
    g_pQuadAux->Unlock();

	g_pd3dDevice->SetStreamSource( 0, g_pQuadAux, 0, sizeof(QUADVERTEX));
	g_pd3dDevice->SetFVF( D3DFVF_QUADVERTEX);
	g_pd3dDevice->SetTexture( 0, g_pTexture[sprites]);

	g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2);
	SAFE_RELEASE(g_pQuadAux);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Fisica basica
/////////////////////////////////////////////////////////////////////////////

BOOL DXEngine2d::colision(POINT p0,POINT p1)
{

	int dx = p1.x-p0.x;
	int dy = p1.y-p0.y;

	if(!dx && !dy)
		return FALSE;		// no se movio

	BOOL rta = FALSE;

	// guardo el pto actual: 
	coli_j = nearest_x(Ip.x = p0.x);
	coli_i = nearest_y(Ip.y = p0.y);


	if(abs(dy)>abs(dx))
	{
		// mov. predominantemente vertical
		int s = sign(dy);
		int y = p0.y + s;
		float x = p0.x;
		float inc_x = (float)dx/(float)abs(dy);
		BOOL seguir = TRUE;
		while(seguir)
		{

			if(y==p1.y)
				seguir = FALSE;		// llego al ultimo punto

			int cant_v = 0;
			int ndx[10];
			if(dy>0)
			{
				// Caida libre
				// puede colisionar con los pies
				ndx[cant_v++] = 0;		// Pie izquierdo
				ndx[cant_v++] = 1;		// Pie Derecho
			}
			else
			{
				// salto
				// puede colisionar con la cabeza
				ndx[cant_v++] = 4;
			}
				
			if(dx>50)
				ndx[cant_v++] = 8;		// Mano Derecha
			else
			if(dx<-50)
				ndx[cant_v++] = 7;		// Mano Izquierda


			int v = 0;
			while(v<cant_v)
			{
				// pos. de la vertebra en el tile:
				int tj = nearest_x(x + vertebra[ndx[v]].x);
				int ti = nearest_y(y - vertebra[ndx[v]].y);

				if(C[ti][tj].flags&TILE_PISO)
				{
					rta = TRUE;			// colision
					seguir = FALSE;		// termina el ciclo
					// guardo el tile que hizo colision (el
					coli_j = tj;
					coli_i = ti;
					// guardo el pto de contacto (vertebra)
					coli_v = ndx[v];
					// termino el ciclo
					break;
				}
				else
					// paso a la siguiente vertebra
					++v;
			}	




			if(seguir)
			{
				// guardo el pto actual: 
				Ip.x = x;
				Ip.y = y;

				// avanzo
				y+=s;
				x+=inc_x;
			}
		}
	}
	else
	{
		// mov. predominantemente horizontal
		int s = sign(dx);
		int x = p0.x + s;
		float y = p0.y;
		float inc_y = (float)dy/(float)abs(dx);
		BOOL seguir = TRUE;
		while(seguir)
		{

			if(x==p1.x)
				seguir = FALSE;		// llego al ultimo punto

			int cant_v = 0;
			int ndx[10];
			if(dx>0)
			{
				ndx[cant_v++] = 8;		// Mano Derecha
				ndx[cant_v++] = 1;		// Pie Derecho
			}
			else
			{
				ndx[cant_v++] = 7;		// Mano Izquierda
				ndx[cant_v++] = 0;		// Pie Izquierdo
			}
			ndx[cant_v++] = 4;		// Cabeza
				

			int v = 0;
			while(v<cant_v)
			{
				// pos. de la vertebra en el tile:
				int tj = nearest_x(x + vertebra[ndx[v]].x);
				int ti = nearest_y(y - vertebra[ndx[v]].y);

				if(C[ti][tj].flags&TILE_PISO)
				{
					rta = TRUE;			// colision
					seguir = FALSE;		// termina el ciclo
					// guardo el tile que hizo colision (el
					coli_j = tj;
					coli_i = ti;
					// guardo el pto de contacto (vertebra)
					coli_v = ndx[v];
					// termino el ciclo
					break;
				}
				else
					// paso a la siguiente vertebra
					++v;
			}	

			if(seguir)
			{
				// guardo el pto actual: 
				Ip.x = x;
				Ip.y = y;
				// avanzo
				x+=s;
				y+=inc_y;
			}
		}
	}

	return rta;
}


void DXEngine2d::Update(float elapsed_time)
{
	ftime += elapsed_time;
	int ant_pos_x = pos_x;
	int ant_pos_y = pos_y;
	int ant_pos_j = nearest_x(pos_x);
	int ant_pos_i = nearest_y(pos_y);

	if(!sobre_piso)
		// fuerza de gravedad
		vel_v += 400*elapsed_time;

	pos_y += elapsed_time*vel_v;

	// Velocidad horizontal
	pos_x += elapsed_time*vel_h;

	// mov. relativo (al pto anterior)
	int dx = pos_x - ant_pos_x;
	int dy = pos_y - ant_pos_y;


	// Verifico las colisiones en la nueva posicion
	if(colision(CPoint(ant_pos_x,ant_pos_y),CPoint(pos_x,pos_y)))
	{
		// hubo colision: me posiciono en el pto de colision
		pos_y = Ip.y;
		pos_x = Ip.x;
		
		if(C[coli_i][coli_j].flags&TILE_PISO)
		{
			//if(abs(dy)>=abs(dx))
			{
				// caida o subida vertical
				if(dy>0 && (coli_v==0 || coli_v==1))
				{
					// estaba cayendo, llega al piso, y termina la caida
					vel_v = 0;
					vel_h = 0;
					sobre_piso = TRUE;
				}
				else
				if(vel_v<0)
					// estaba saltando, choca contra el techo, rebota para abajo
					vel_v *=-1;
			}
			
			//else
			{
				// movimiento horizontal, choca contra una pared
				// si no estaba en el piso, rebota horizontalmente
				if(!sobre_piso)
					vel_h*=-1;
			}
		
		}

	}
}


// x convencion pos_x, pos_y, representa la esquina inferior, izquierda del sprite
int DXEngine2d::nearest_x(int x)
{
	return (float)x/ (float)tile_dx;
}


int DXEngine2d::nearest_y(int y)
{
	return (float)y/(float)tile_dy;
}


BOOL DXEngine2d::esta_sobre_piso()
{
	BOOL rta = FALSE;
	// pos_x,pos_y es la esquina inferior izquierda
	// nearest point: 
	int pos_j = nearest_x(pos_x+vertebra[0].x);
	int pos_i = nearest_y(pos_y+vertebra[0].y+1);
	if(C[pos_i][pos_j].flags&(TILE_PISO | TILE_ESCALERA))
		rta = TRUE;		// el pie izquierdo apoya
	else
	{
		pos_j = nearest_x(pos_x+vertebra[1].x);
		pos_i = nearest_y(pos_y+vertebra[1].y+1);
		if(C[pos_i][pos_j].flags&TILE_PISO)
			rta = TRUE;		// el pie derecho
	}

	return rta;
}


// Control de mov. horizontal
void DXEngine2d::Move(int dx,int dy)
{
	if(!sobre_piso)
		//dx /= 2;
		dx = sign(dx);

	// Verifico las colisiones en la nueva posicion
	if(!colision(CPoint(pos_x,pos_y),CPoint(pos_x+dx,pos_y+dy)))
	{
		pos_x+=dx;
		pos_y+=dy;

		// verifico la nueva posicion
		if(sobre_piso && dx)
		{
			// Si estaba sobre el piso, y se movio para la derecha o para la izquierda
			// se puede caer, (si no hay mas piso en el nuevo lugar)
			if(!esta_sobre_piso())
			{
				// empieza a caer
				sobre_piso = FALSE;
				vel_v = 40;
			}
		}
	}
}



// Baja la escalera 
void DXEngine2d::Bajar(int dy)
{

	// Verifico las colisiones en la nueva posicion
	BOOL pos_ok = TRUE;
	if(colision(CPoint(pos_x,pos_y),CPoint(pos_x,pos_y+dy)))
	{
		// hubo colision, pero la escalera es un caso particular 
		// solo importa colision con el piso solo, (no importa si colisiona con piso + escalera)
		if(C[coli_i][coli_j].flags&TILE_ESCALERA)
			// es como si no habria colision
			pos_y += dy;
		else
			// colision pp dicha, me posiciono en el ultimo pto que no colisiono
			pos_y = Ip.y;
	}
	else
		pos_y += dy;
	
	sobre_piso = TRUE;
}

